pragma solidity ^0.4.13;


contract OutRandom {

	address public owner; //address who can update random

	//max integer result
	uint8 public maxResult;

	//number of requests in array
	uint public requestsCount;

	//random request structure
	struct Request {
		address customer; //address who needs random
		uint256 block; //number of block where request is placed
		bytes32 seed; //random is generated by the seed
		uint8 result; //random generated value
	}

	//indexed requests storage
	mapping (uint => Request) requests;

	function OutRandom() {
		requestsCount = 0;
		owner = msg.sender;
		maxResult = 37;
	}

	modifier onlyOwner {
		if (msg.sender != owner) {
			revert();
		}
		_;
	}

	function() {
		revert();
	}

	//place request for random number
	function placeRequest() public returns (uint placed) {
		placed = requestsCount;
		requests[requestsCount] = Request(msg.sender, block.number, '', 0);
		requestsCount++;
	}

	//something to review our db of requests
	function getRequest(uint index) constant returns (address a, uint256 b, bytes32 c, uint8 d) {
		a = requests[index].customer;
		b = requests[index].block;
		c = requests[index].seed;
		d = requests[index].result;
	}

	//someone gives us seed for request
	function updateRequestSeed(uint index, bytes32 seed) onlyOwner returns (bool) {
		if (requests[index].seed != 0x0) {
			revert();
		}
		requests[index].seed = seed;
	}

	//someone updates real number from seed
	function updateRequestResult(uint index, uint8 result) returns (bool) {
		if (requests[index].seed == 0x0) {
			revert();
		}
		if (sha3(result, msg.sender) != requests[index].seed) {
			revert();
		}

		requests[index].result = uint8(result % maxResult);
	}
}
